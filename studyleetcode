#leetcode 345
class Solution345:
    def reverseVowels(self, s: str) -> str:
        length=len(s)
        low,high=0,length-1
        s=list(s)
        res =['a','e','i','o','u','A','E','I','O','U']
        while low<=high:
            while low<high and s[high] not in res:
                high-=1
            while low<high and s[low] not in res:
                low+=1
            s[low],s[high]=s[high],s[low]
            low+=1
            high-=1
        return "".join(s)


#leetcode 524
class Solution524:
    def findLongestWord(self, s: str, d: List[str]) -> str:
        d.sort(key=lambda x:[-len(x),x])
        for word in d:
            a=0
            b=0
            while a<len(s) and b<len(word):
                if s[a]==word[b]:
                    a+=1
                    b+=1
                else:
                    a+=1
            if len(word) ==b:
                return word
        return ''
        
        #leetcode 141
class Solution141:
    def hasCycle(self, head: ListNode) -> bool:
        if not head:
            return head
        slow=head
        quick=head
        while quick and slow:
            slow=slow.next
            if quick.next:
                quick=quick.next.next
            else:
                return False
            if quick is slow:
                return True
        return False

#leetcode 315
class Solution315:
    def countSmaller(self, nums: List[int]) -> List[int]:
        sortns=[]
        res=[]
        for n in reversed(nums):
            idx=bisect.bisect_left(sortns,n)
            res.append(idx)
            sortns.insert(idx,n)
        return res[::-1]


#leetcode 120
class Solution120:
    def minimumTotal(self, triangle: List[List[int]]) -> int:
        for r in range(len(triangle)-2,-1,-1):
            for c in range(len(triangle[r])):
                triangle[r][c]+=min(triangle[r+1][c:c+2])
        return triangle[0][0]


#leetcode 96
class Solution96:
    def numTrees(self, n: int) -> int:
        s=[0]*(n+1)
        s[0]=1

        for i in range(1,n+1):
            b=i-1
            for j in range(i//2):
                s[i]+=s[j]*s[b-j]
            s[i]*=2

            if i%2==1:
                s[i]+=s[i//2]**2
        return s[-1]


#leetcode 35
class Solution35:
    def searchInsert(self, nums: List[int], target: int) -> int:
        left,right =0,len(nums)
        while left<right:
            mid=left+(right-left)//2
            if nums[mid]<target:
                left=mid+1
            else:
                right=mid
        return left


#leetcode 312
class Solution312:
    def maxCoins(self, nums: List[int]) -> int:
        nums.insert(0,1)
        nums.insert(len(nums),1)

        store=[[0]*(len(nums)) for i in range(len(nums))]

        def range_best(i,j):
            m=0
            for k in range(i+1,j):
                left=store[i][k]
                right=store[k][j]
                a=left+nums[i]*nums[k]*nums[j]+right
                if a>m:
                    m=a
            store[i][j]=m

        for n in range(2,len(nums)):
            for i in range(0,len(nums)-n):
                range_best(i,i+n)
        return store[0][len(nums)-1]

