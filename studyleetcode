#leetcode 345
class Solution345:
    def reverseVowels(self, s: str) -> str:
        length=len(s)
        low,high=0,length-1
        s=list(s)
        res =['a','e','i','o','u','A','E','I','O','U']
        while low<=high:
            while low<high and s[high] not in res:
                high-=1
            while low<high and s[low] not in res:
                low+=1
            s[low],s[high]=s[high],s[low]
            low+=1
            high-=1
        return "".join(s)


#leetcode 524
class Solution524:
    def findLongestWord(self, s: str, d: List[str]) -> str:
        d.sort(key=lambda x:[-len(x),x])
        for word in d:
            a=0
            b=0
            while a<len(s) and b<len(word):
                if s[a]==word[b]:
                    a+=1
                    b+=1
                else:
                    a+=1
            if len(word) ==b:
                return word
        return ''
        
        #leetcode 141
class Solution141:
    def hasCycle(self, head: ListNode) -> bool:
        if not head:
            return head
        slow=head
        quick=head
        while quick and slow:
            slow=slow.next
            if quick.next:
                quick=quick.next.next
            else:
                return False
            if quick is slow:
                return True
        return False

#leetcode 315
class Solution315:
    def countSmaller(self, nums: List[int]) -> List[int]:
        sortns=[]
        res=[]
        for n in reversed(nums):
            idx=bisect.bisect_left(sortns,n)
            res.append(idx)
            sortns.insert(idx,n)
        return res[::-1]


#leetcode 120
class Solution120:
    def minimumTotal(self, triangle: List[List[int]]) -> int:
        for r in range(len(triangle)-2,-1,-1):
            for c in range(len(triangle[r])):
                triangle[r][c]+=min(triangle[r+1][c:c+2])
        return triangle[0][0]


#leetcode 96
class Solution96:
    def numTrees(self, n: int) -> int:
        s=[0]*(n+1)
        s[0]=1

        for i in range(1,n+1):
            b=i-1
            for j in range(i//2):
                s[i]+=s[j]*s[b-j]
            s[i]*=2

            if i%2==1:
                s[i]+=s[i//2]**2
        return s[-1]


#leetcode 35
class Solution35:
    def searchInsert(self, nums: List[int], target: int) -> int:
        left,right =0,len(nums)
        while left<right:
            mid=left+(right-left)//2
            if nums[mid]<target:
                left=mid+1
            else:
                right=mid
        return left


#leetcode 312
class Solution312:
    def maxCoins(self, nums: List[int]) -> int:
        nums.insert(0,1)
        nums.insert(len(nums),1)

        store=[[0]*(len(nums)) for i in range(len(nums))]

        def range_best(i,j):
            m=0
            for k in range(i+1,j):
                left=store[i][k]
                right=store[k][j]
                a=left+nums[i]*nums[k]*nums[j]+right
                if a>m:
                    m=a
            store[i][j]=m

        for n in range(2,len(nums)):
            for i in range(0,len(nums)-n):
                range_best(i,i+n)
        return store[0][len(nums)-1]



#leetcode 97
class Solution97:
    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:
        m,n=len(s1),len(s2)
        if m+n!=len(s3):
            return False
        dp=[[False]*(n+1) for _ in range(m+1)]
        dp[0][0]=True
        for i in range(1,m+1):
            dp[i][0]=dp[i-1][0] and (s3[i-1]==s1[i-1])
        for i in range(1,n+1):
            dp[0][i]=dp[0][i-1] and (s3[i-1]==s2[i-1])

        for i in range(1,m+1):
            for j in range(1,n+1):
                dp[i][j]=(dp[i-1][j] and (s3[i+j-1]== s1[i-1])) or (dp[i][j-1] and (s3[i+j-1]==s2[j-1]))
        return dp[-1][-1]

#leetcode 剑指offer11
class Solutionoffer11:
    def minArray(self, numbers: List[int]) -> int:
        i,j=0,len(numbers)-1
        while i<j:
            m=(i+j)//2
            if numbers[m]>numbers[j]:i=m+1
            elif numbers[m]<numbers[j]:j=m
            else:i-=1
        return numbers[i]


#leetcode64
class Solution64:
    def minPathSum(self, grid: List[List[int]]) -> int:
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if i==j==0:continue
                elif i==0:grid[i][j]=grid[i][j-1]+grid[i][j]
                elif j==0:grid[i][j]=grid[i-1][j]+grid[i][j]
                else:grid[i][j]=min(grid[i-1][j],grid[i][j-1])+grid[i][j]
        return grid[-1][-1]


#leetcode 95
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution95:
    def generateTrees(self, n: int) -> List[TreeNode]:
        if n==0:
            return []
        dct={}

        def left_right(left:int,right:int)->List[TreeNode]:
            if left>right:
                return [None]
            if (left,right) in dct:
                return dct[(left,right)]
            ret=[]

            for i in range(left,right+1):
                left_lst=left_right(left,i-1)
                right_lst=left_right(i+1,right)
                for L in left_lst:
                    for R in right_lst:
                        app_Tree=TreeNode(i)
                        app_Tree.left=L
                        app_Tree.right=R
                        ret.append(app_Tree)
            dct[(left,right)]=ret
            return ret
        left_right(1,n)
        return left_right(1,n)

#leetcode410
class Solution410:
    def splitArray(self, nums: List[int], m: int) -> int:
        n = len(nums)
        f = [[10**18] * (m + 1) for _ in range(n + 1)]
        sub = [0]
        for elem in nums:
            sub.append(sub[-1] + elem)

        f[0][0] = 0
        for i in range(1, n + 1):
            for j in range(1, min(i, m) + 1):
                for k in range(i):
                    f[i][j] = min(f[i][j], max(f[k][j - 1], sub[i] - sub[k]))

        return f[n][m]


class Solution329:
    def longestIncreasingPath(self, matrix: List[List[int]]) -> int:
        if not matrix:
            return 0
        x=len(matrix)
        y=len(matrix[0])
        dp=[[1 for _ in range(y)] for _ in range(x)]
        numsSort=sorted(sum([[(matrix[i][j],i,j) for j in range(y)] for i in range(x)],[]))
        for i,j,k in numsSort:
            dp[j][k]=1+max(dp[j-1][k] if j and matrix[j-1][k]<i else 0,
                           dp[j][k-1] if k and matrix[j][k-1]<i else 0, 
                            dp[j+1][k] if j != x-1 and matrix[j+1][k]<i else 0, 
                            dp[j][k+1] if k != y-1 and matrix[j][k+1]<i else 0)
        
        return max(sum(dp,[]))


#leetcode392
class Solution392:
    def isSubsequence(self, s: str, t: str) -> bool:
        n,m=len(s),len(t)
        inx=-1
        for i in range(n):
            for j in range(inx+1,m):
                if t[j]==s[i]:
                    inx=j
                    break
            else:
                return False
        return True

#leetcode104
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution104:
    def maxDepth(self, root: TreeNode) -> int:
        return 0 if not root else max(self.maxDepth(root.left),self.maxDepth(root.right))+1


#leetcode503
class Solution503:
    def nextGreaterElements(self, nums: List[int]) -> List[int]:
        if not nums:
            return []
        length=len(nums)

        nums=nums+nums
        result=[-1]*length
        stack=[0]

        for i in range(1,len(nums)):
            while(stack and nums [stack[-1]]<nums[i]):
                target=stack.pop()
                result[target%length]=nums[i]
            stack.append(i%length)
        return result


#leetcode343
class Solution343:
    def integerBreak(self, n: int) -> int:
        if n <= 3:
            return n-1
        a,b=n//3,n%3
        if b==0:
            return int(math.pow(3,a))
        if b==1:
            return int(math.pow(3,a-1)*4)
        return int(math.pow(3,a)*2)
      
#leetcode328
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution328:
    def oddEvenList(self, head: ListNode) -> ListNode:
        if not head:return head
        odd=head
        even_head=even=head.next
        while odd.next and even.next:
            odd.next=odd.next.next
            even.next=even.next.next
            odd,even=odd.next,even.next
        odd.next=even_head
        return head
 

#leetcode634
import heapq
class Solution634:
    def smallestRange(self, nums: List[List[int]]) -> List[int]:
        k=len(nums)
        elem_id_index=[(elem[0],id,0) for id,elem in enumerate(nums)]
        heapq.heapify(elem_id_index)
        maxval,minval=1e5,-1e5
        currmaxcal=max(elem_id_index)[0]

        while True:
            currmincal,id,index=heapq.heappop(elem_id_index)
            if currmaxcal-currmincal<maxval-minval:
                maxval=currmaxcal
                minval=currmincal
            if index<len(nums[id])-1:
                val=nums[id][index+1]
                currmaxcal=max(currmaxcal,val)
                heapq.heappush(elem_id_index,(val,id,index+1))
            else:
                break
        return [minval,maxval]

